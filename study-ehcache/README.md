## 集成Ehcache

### 介绍

> - EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。
>- Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。
>- 它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。

### 特性

> - 快速、简单
>- 多种缓存策略
>- 缓存数据有两级：内存和磁盘，因此无需担心容量问题
>- 缓存数据会在虚拟机重启的过程中写入磁盘
>- 可以通过RMI、可插入API等方式进行分布式缓存
>- 具有缓存和缓存管理器的侦听接口
>- 支持多缓存管理器实例，以及一个实例的多个缓存区域
>- 提供Hibernate的缓存实现

### 集成

> - 可以单独使用，一般在第三方库中被用到的比较多（如mybatis、shiro等）ehcache 对分布式支持不够好，多个节点不能同步，通常和redis一块使用

### 灵活性

> - ehcache具备对象api接口和可序列化api接口
>- 不能序列化的对象可以使用出磁盘存储外ehcache的所有功能
>- 支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。
>- 提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。
>- 提供内存和磁盘存储，Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。
>- 动态、运行时缓存配置，存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。

### 应用持久化

> - 在vm重启后，持久化到磁盘的存储可以复原数据
>- EhCache是第一个引入缓存数据持久化存储的开源java缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得
>- 根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.flush方法执行,这大大方便了ehcache的使用

### ehcache 和 redis 比较

> - ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。
>- redis是通过socket访问到缓存服务，效率比ehcache低，比数据库要快很多，
>- 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。

### 配置项

> - name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象
>- maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个
>- clearOnFlush：内存数量最大时是否清除。
>- eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时
>- timeToIdleSeconds ： 设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
>- timeToLiveSeconds ：缓存数据的 生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。(和上面的两者取最小值)
>- overflowToDisk：内存不足时，是否启用磁盘缓存。
>- maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。
>- maxElementsOnDisk：硬盘最大缓存个数。
>- diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
>- diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。
>- diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
>- memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。这里比较遗憾，Ehcache并没有提供一个用户定制策略的接口，仅仅支持三种指定策略，感觉做的不够理想。

### 一致性模型

> - 说到一致性，数据库的一致性是怎样的？不妨先来回顾一下数据库的几个隔离级别：
>- 未提交读（Read Uncommitted）：在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。会出现脏读、不可重复读、幻象读。
>- 已提交读（Read Committed）：只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是数据库的默认隔离级别。会出现不可重复读、幻象读。
>- 可重复读（Repeatable Read）：像已提交读级别那样读数据，但会保持共享锁直到事务结束。会出现幻象读。
>- 可序列化（Serializable）：工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围，这就阻止了新数据插入查询所涉及的范围。

### 模型分类

> - 强一致性模型：系统中的某个数据被成功更新(事务成功返回)后，后续任何对该数据的读取操作都得到到更新后的值。这是传统关系数据库提供的一致性模型，也是关系数据库深受人们喜爱的原因之一。强一致性模型下的性能消耗通常是最大的
>- 弱一致性模型：系统中的某个数据被更新后，后续对该数据的读取操作得到的不一定是更新后的值，这种情况下通常有个“不一致性时间窗口”存在：即数据更新完成后在经过这个时间窗口，后续读取操作就能够得到更新后的值。
>- 最终一致性模型：属于弱一致性的一种，即某个数据被更新后，如果该数据后续没有被再次更新，那么最终(没有时间窗口)所有的读取操作都会返回更新后的值
>- Bulk Load：这种模型是基于批量加载数据到缓存里面的场景而优化的，没有引入锁和常规的淘汰算法这些降低性能的东西，它和最终一致性模型很像，但是有批量、高速写和弱一致性保证的机制。
>- 最终一致性模型包含如下几个必要属性
> 1. 读写一致：某线程A，更新某条数据以后，后续的访问全部都能取得更新后的数据。
> 1. 会话内一致：它本质上和上面那一条是一致的，某用户更改了数据，只要会话还存在，后续他取得的所有数据都必须是更改后的数据。
> 1. 单调读一致：如果一个进程可以看到当前的值，那么后续的访问不能返回之前的值。
> 1. 单调写一致：对同一进程内的写行为必须是保序的，否则，写完毕的结果就是不可预期的了。·

### API

1. 显式锁（Explicit Locking ）：如果我们本身就配置为强一致性，那么自然所有的缓存操作都具备事务性质。而如果我们配置成最终一致性时，再在外部使用显式锁API，也可以达到事务的效果。当然这样的锁可以控制得更细粒度，但是依然可能存在竞争和线程阻塞。
2. 无锁可读取视图（UnlockedReadsView）：一个允许脏读的decorator，它只能用在强一致性的配置下，它通过申请一个特殊的写锁来比完全的强一致性配置提升性能。 举例如下，xml配置为强一致性模型：

```xml

<cache name="myCache"
       maxElementsInMemory="500"
       eternal="false"
       overflowToDisk="false">
    <terracotta clustered="true" consistency="strong"/>
</cache>  
```

但是使用UnlockedReadsView：

```java
Cache cache=cacheManager.getEhcache("myCache");
        UnlockedReadsView unlockedReadsView=new UnlockedReadsView(cache,"myUnlockedCache");  //代码上设置
```

3. 原子方法（Atomic methods）：方法执行是原子化的，即CAS操作（Compare and
   Swap）。CAS最终也实现了强一致性的效果，但不同的是，它是采用乐观锁而不是悲观锁来实现的。在乐观锁机制下，更新的操作可能不成功，因为在这过程中可能会有其他线程对同一条数据进行变更，那么在失败后需要重新执行更新操作。现代的CPU都支持CAS原语了。

```java
cache.putIfAbsent(Element element);
        cache.replace(Element oldOne,Element newOne);
        cache.remove(Element);
```

### spring注解
>- Spring对缓存的支持类似于对事务的支持。
>- 首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。
---

- 以上内容引用 [EhCache](https://www.jianshu.com/p/154c82073b07)
- 代码参考 [Spring Boot 缓存应用 Ehcache 入门教程](https://www.cnblogs.com/fishpro/p/spring-boot-study-ehcache.html)
